import type { ParametricBand } from "./types";
import { SyncStatus } from "./use-equalizer";
import * as tauri from "./tauri";

export function generateId(): string {
    return Math.random().toString(36).substring(2, 9);
}

import { save } from '@tauri-apps/plugin-dialog';
import { writeTextFile } from '@tauri-apps/plugin-fs';

export async function handleExportProfile(
    currentProfile: string | null,
    preamp: number,
    bands: ParametricBand[]
) {
    const profile = {
        name: currentProfile || "Untitled",
        preamp,
        bands: bands.map(({ filter_type, frequency, gain, q_factor }) => ({
            filter_type,
            frequency,
            gain,
            q_factor,
        })),
    };

    const json = JSON.stringify(profile, null, 2);

    try {
        const path = await save({
            defaultPath: `${profile.name.replace(/[^a-z0-9]/gi, "_")}.json`,
            filters: [{
                name: 'EQAPO GUI Profile',
                extensions: ['json']
            }]
        });

        if (path) {
            await writeTextFile(path, json);
        }
    } catch (err) {
        console.error("Export failed:", err);
    }
}

export function handleImportProfile(
    setBands: (bands: ParametricBand[]) => void,
    setPreamp: (preamp: number) => void,
    setCurrentProfile: (name: string) => void,
    setSyncStatus: (status: SyncStatus) => void,
    setError: (error: string | null) => void,
    preamp: number,
    configPath?: string | null
) {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";

    input.onchange = async (e) => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (!file) return;

        try {
            const text = await file.text();
            const data = JSON.parse(text);

            // Validate structure
            if (!Array.isArray(data.bands)) {
                throw new Error("Invalid profile format: missing bands array");
            }

            // Load bands with new IDs
            const importedBands: ParametricBand[] = data.bands.map(
                (b: Omit<ParametricBand, "id">) => ({
                    id: generateId(),
                    filter_type: b.filter_type || "peaking",
                    frequency: Number(b.frequency) || 1000,
                    gain: Number(b.gain) || 0,
                    q_factor: Number(b.q_factor) || 1.41,
                })
            );

            setBands(importedBands);
            if (typeof data.preamp === "number") {
                setPreamp(data.preamp);
            }
            if (data.name) {
                setCurrentProfile(data.name);
            }

            // Auto-apply imported settings
            setSyncStatus("syncing");
            await tauri.applyProfile(importedBands, data.preamp ?? preamp, configPath);
            setSyncStatus("synced");
            setError(null);
        } catch (err) {
            setError(`Import failed: ${err}`);
            setSyncStatus("error");
        }
    };

    input.click();
}


export async function handleExportTxt(
    currentProfile: string | null,
    preamp: number,
    bands: ParametricBand[]
) {
    let content = `; EQAPO GUI Profile: ${currentProfile || "Untitled"}\n`;
    content += `; Generated by EQAPO GUI\n\n`;
    content += `Preamp: ${preamp.toFixed(1)} dB\n\n`;

    bands.forEach((band, index) => {
        // Format: Filter <n>: ON <Type> Fc <Freq> Hz Gain <Gain> dB Q <Q>
        let type = "";
        switch (band.filter_type) {
            case "peaking": type = "PK"; break;
            case "lowshelf": type = "LS"; break;
            case "highshelf": type = "HS"; break;
        }

        content += `Filter ${index + 1}: ON ${type} Fc ${band.frequency} Hz Gain ${band.gain.toFixed(1)} dB Q ${band.q_factor.toFixed(2)}\n`;
    });

    try {
        const path = await save({
            defaultPath: `${(currentProfile || "config").replace(/[^a-z0-9]/gi, "_")}.txt`,
            filters: [{
                name: 'Configuration File',
                extensions: ['txt']
            }]
        });

        if (path) {
            await writeTextFile(path, content);
        }
    } catch (err) {
        console.error("Export failed:", err);
    }
}

export function handleImportTxt(
    setBands: (bands: ParametricBand[]) => void,
    setPreamp: (preamp: number) => void,
    setSyncStatus: (status: SyncStatus) => void,
    setError: (error: string | null) => void
) {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".txt";

    input.onchange = async (e) => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (!file) return;

        try {
            const text = await file.text();
            const bands: ParametricBand[] = [];
            let newPreamp = 0;

            // Parse Preamp
            const preampMatch = text.match(/Preamp:\s*([+-]?\d*\.?\d+)\s*dB/i);
            if (preampMatch) {
                newPreamp = parseFloat(preampMatch[1]);
            }

            // Parse Filters
            const lines = text.split('\n');
            lines.forEach(line => {
                // Match standard EQ APO filter syntax
                // Filter 1: ON PK Fc 1000 Hz Gain -2.0 dB Q 1.41
                if (line.trim().startsWith("Filter")) {
                    const typeMatch = line.match(/(PK|LS|HS|Peaking|LowShelf|HighShelf)/i);
                    const freqMatch = line.match(/Fc\s+(\d+(?:\.\d+)?)/i);
                    const gainMatch = line.match(/Gain\s+([+-]?\d+(?:\.\d+)?)/i);
                    const qMatch = line.match(/Q\s+(\d+(?:\.\d+)?)/i);

                    if (freqMatch && gainMatch && qMatch) {
                        let filterType: "peaking" | "lowshelf" | "highshelf" = "peaking";
                        if (typeMatch) {
                            const t = typeMatch[1].toUpperCase();
                            if (t === "LS" || t === "LOWSHELF") filterType = "lowshelf";
                            if (t === "HS" || t === "HIGHSHELF") filterType = "highshelf";
                        }

                        bands.push({
                            id: generateId(),
                            filter_type: filterType,
                            frequency: parseFloat(freqMatch[1]),
                            gain: parseFloat(gainMatch[1]),
                            q_factor: parseFloat(qMatch[1])
                        });
                    }
                }
            });

            if (bands.length > 0) {
                setBands(bands);
                setPreamp(newPreamp);
                setSyncStatus("pending"); // Let the hook implementation handle the sync
                setError(null);
            } else {
                throw new Error("No valid filters found in file");
            }

        } catch (err) {
            setError(`Import failed: ${err}`);
            setSyncStatus("error");
        }
    };

    input.click();
}
